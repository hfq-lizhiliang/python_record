

```python
a = ['a','b','c','d','e','f','g','h']
```


```python
print a[:4] #前四个
```

    ['a', 'b', 'c', 'd']
    


```python
print a[-4:] #后四个
```

    ['e', 'f', 'g', 'h']
    


```python
print a[3:-3] #第四个到倒数第四个
```

    ['d', 'e']
    

当切片是从头开始的话，下标0可以省略  a[:3] = a[0:3]

分片中使用负数对于从后往前的操作很方便。负数的绝对值就是相对于末尾数据的偏移量。所有的形式对于新手而言也都是清晰的。


```python
a[:]
```




    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']




```python
a[:5]
```




    ['a', 'b', 'c', 'd', 'e']




```python
a[:-1]
```




    ['a', 'b', 'c', 'd', 'e', 'f', 'g']




```python
a[4:]
```




    ['e', 'f', 'g', 'h']




```python
a[-3:]
```




    ['f', 'g', 'h']




```python
a[2:5]
```




    ['c', 'd', 'e']




```python
a[2:-1]
```




    ['c', 'd', 'e', 'f', 'g']




```python
a[-3:-1]
```




    ['f', 'g']



分片机制将自动处理超出集合边界的下标的取值，这也使得建立一个最大长度的输入序列更加的容易。


```python
a[:20]
```




    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']




```python
a[-20:]
```




    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']



对比起来，直接索引到与上边相同的下标会引发一个异常


```python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
```


```python
a[8]
```


    ---------------------------------------------------------------------------

    IndexError                                Traceback (most recent call last)

    <ipython-input-18-7749ee2033a3> in <module>()
    ----> 1 a[8]
    

    IndexError: list index out of range



```python
a[:8]
```




    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']



对比a[8]和a[:8]的计算结果，发现a[8]数组下标越界了，而a[:8]正常，发生这个异常的原因就在于分片机制下数字是指相对于开始位置的offset（偏移量），而单纯的使用下标的话还是需要遵守列表的访问规则的。


```python

```

分片不会改变原始的数据，返回的仍然是一个列表。而原来的列表的值并不会发生变化，对返回的列表进行操作不会影响到原来的列表的值。


```python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
```


```python
b = a[4:]
```


```python
b #原值
```




    ['e', 'f', 'g', 'h']




```python
b[1] = 99
```


```python
b #后值
```




    ['e', 99, 'g', 'h']




```python
a #切片前
```




    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']




```python
a[2:7] = [99,22,14]
```


```python
a
```




    ['a', 'b', 99, 22, 14, 'h']



对比上面的赋值结果，发现a在切片赋值后，分片的赋值将会替换切片范围内的空间，切片的赋值长度不必与切片范围一致，就如上面的例子，切片的范围a[2:7]比赋值[99,22,14]的范围大，赋值替换了切片的范围.


```python
b = a[:]
```


```python
b
```




    ['a', 'b', 99, 22, 14, 'h']



对比上面的结果，如果省略开头索引和结尾索引，就会获得原始列表的拷贝版本。


```python
b = a
```


```python
print 'Before:',a
```

    Before: ['a', 'b', 99, 22, 14, 'h']
    


```python
a[:] = [101,102,103]
```


```python
print 'After:',a
```

    After: [101, 102, 103]
    

当为列表赋值的时候省去开头和结尾下标的时候，将会用这个引用来替换整个列表的内容，而不是创建一个新的列表。同时，引用了这个列表的列表的相关内容，也会跟着发生变化。


```python

```


```python

```
